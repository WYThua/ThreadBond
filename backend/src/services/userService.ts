import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { emailService } from './emailService';

const prisma = new PrismaClient();

export interface RegisterUserData {
  email: string;
  password: string;
}

export interface UserWithToken {
  user: {
    id: string;
    email: string;
    createdAt: Date;
    isActive: boolean;
  };
  token: string;
  anonymousIdentity: {
    id: string;
    displayName: string;
    avatarUrl: string;
  };
}

class UserService {
  /**
   * 用户注册
   */
  async registerUser(userData: RegisterUserData): Promise<UserWithToken> {
    const { email, password } = userData;

    // 检查邮箱是否已存在
    const existingUser = await prisma.user.findUnique({
      where: { email }
    });

    if (existingUser) {
      throw new Error('该邮箱已被注册');
    }

    // 密码加密
    const saltRounds = 12;
    const passwordHash = await bcrypt.hash(password, saltRounds);

    // 创建用户
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        lastActiveAt: new Date()
      }
    });

    // 自动生成匿名身份
    const anonymousIdentity = await this.generateAnonymousIdentity(user.id);

    // 创建默认用户偏好
    await prisma.userPreferences.create({
      data: {
        userId: user.id,
        clueTypes: ['TEXT', 'IMAGE'],
        difficultyLevel: 'MEDIUM',
        notificationSettings: {
          chatNotifications: true,
          clueNotifications: true,
          emailNotifications: false
        },
        privacySettings: {
          showOnlineStatus: false,
          allowDirectMessages: true
        },
        dataRetentionSettings: {
          chatHistoryRetentionDays: 30,
          clueRetentionDays: 90,
          autoDeleteEnabled: true
        }
      }
    });

    // 生成 JWT token
    const token = this.generateToken(user.id);

    // 发送欢迎邮件（异步，不阻塞注册流程）
    emailService.sendWelcomeEmail(email).catch(console.error);

    return {
      user: {
        id: user.id,
        email: user.email,
        createdAt: user.createdAt,
        isActive: user.isActive
      },
      token,
      anonymousIdentity: {
        id: anonymousIdentity.id,
        displayName: anonymousIdentity.displayName,
        avatarUrl: anonymousIdentity.avatarUrl || ''
      }
    };
  }

  /**
   * 生成匿名身份
   */
  async generateAnonymousIdentity(userId: string) {
    // 生成随机昵称和头像
    const displayName = this.generateRandomDisplayName();
    const avatarUrl = this.generateRandomAvatar();
    const personalityTraits = this.generateRandomPersonalityTraits();

    const anonymousIdentity = await prisma.anonymousIdentity.create({
      data: {
        userId,
        displayName,
        avatarUrl,
        personalityTraits,
        isAutoGenerated: true
      }
    });

    return anonymousIdentity;
  }

  /**
   * 生成随机昵称
   */
  private generateRandomDisplayName(): string {
    const adjectives = [
      '神秘的', '有趣的', '聪明的', '温暖的', '冷静的', '活泼的', '深沉的', '优雅的',
      '勇敢的', '温柔的', '机智的', '独特的', '迷人的', '睿智的', '幽默的', '真诚的'
    ];
    
    const nouns = [
      '旅行者', '探索者', '思考者', '梦想家', '创造者', '观察者', '倾听者', '守护者',
      '冒险家', '艺术家', '哲学家', '诗人', '学者', '导师', '朋友', '伙伴'
    ];

    const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
    const noun = nouns[Math.floor(Math.random() * nouns.length)];
    const number = Math.floor(Math.random() * 999) + 1;

    return `${adjective}${noun}${number}`;
  }

  /**
   * 生成随机头像URL
   */
  private generateRandomAvatar(): string {
    // 使用 DiceBear API 生成随机头像
    const styles = ['avataaars', 'bottts', 'identicon', 'initials', 'personas'];
    const style = styles[Math.floor(Math.random() * styles.length)];
    const seed = Math.random().toString(36).substring(7);
    
    return `https://api.dicebear.com/7.x/${style}/svg?seed=${seed}`;
  }

  /**
   * 生成随机个性特征
   */
  private generateRandomPersonalityTraits(): string[] {
    const allTraits = [
      '内向', '外向', '创意', '逻辑', '感性', '理性', '乐观', '现实',
      '冒险', '稳重', '幽默', '严肃', '好奇', '专注', '社交', '独立'
    ];

    // 随机选择 3-5 个特征
    const numTraits = Math.floor(Math.random() * 3) + 3;
    const shuffled = allTraits.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, numTraits);
  }

  /**
   * 生成 JWT token
   */
  private generateToken(userId: string): string {
    const payload = {
      userId,
      type: 'access'
    };

    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error('JWT_SECRET 环境变量未设置');
    }
    
    return jwt.sign(payload, secret, {
      expiresIn: process.env.JWT_EXPIRES_IN || '7d'
    } as any);
  }

  /**
   * 验证用户登录
   */
  async authenticateUser(email: string, password: string): Promise<UserWithToken> {
    const user = await prisma.user.findUnique({
      where: { email },
      include: {
        anonymousIdentities: {
          where: { isAutoGenerated: true },
          take: 1
        }
      }
    });

    if (!user || !user.isActive) {
      throw new Error('用户不存在或已被禁用');
    }

    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
    if (!isPasswordValid) {
      throw new Error('密码错误');
    }

    // 更新最后活跃时间
    await prisma.user.update({
      where: { id: user.id },
      data: { lastActiveAt: new Date() }
    });

    const token = this.generateToken(user.id);
    const anonymousIdentity = user.anonymousIdentities[0];

    return {
      user: {
        id: user.id,
        email: user.email,
        createdAt: user.createdAt,
        isActive: user.isActive
      },
      token,
      anonymousIdentity: {
        id: anonymousIdentity.id,
        displayName: anonymousIdentity.displayName,
        avatarUrl: anonymousIdentity.avatarUrl || ''
      }
    };
  }

  /**
   * 根据ID获取用户信息
   */
  async getUserById(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        anonymousIdentities: true,
        preferences: true
      }
    });

    if (!user) {
      throw new Error('用户不存在');
    }

    return user;
  }
}

export const userService = new UserService();